---
layout: post
title: "CIでのCarthageのキャッシュの効率的な当て方"
date: 2018-12-06 08:00 +0900
---

Carthageによるフレームワークのビルドは時間が掛かるので、CIでは良い感じにキャッシュを当ててもらいたい。この記事の中ではそれをやってくれる平凡な設定を貼るのだけど、なぜそれが効率的なのか理解するにはCarthageとCIのキャッシュの仕組みを理解する必要があるので、まとめておく。我が社([エンジニア募集中](https://docs.google.com/forms/d/e/1FAIpQLSdxXuqZGRP-ZNKNKaKLOYfxqyL33H_cb0LqOM5l9QUTqln1rw/viewform))のCIはすべてCircleCIなのでCircleCIの話になるのだけど、たぶん他のCIサービスでも似た仕組みはありそう。

ちなみにこれは、半年ほど前に [@chuganzy](https://twitter.com/chuganzy) さんにTwitterで教えてもらったのがきっかけで調べ始めたもの。ずっとやろうと思ってたのだけど全然やってなくて、遂にやった。うっかりしている間に半年も経っていて、自分の先延ばし能力に驚かされた...。

## Carthageのキャッシュ

Carthage 0.20(2017年2月リリース)からCarthageの`bootstrap`コマンドには`--cache-builds`というオプションが入っていて、これを使えば再ビルドが不要なフレームワークのビルドはスキップしてくれる。

再ビルドが必要かどうかの判定には、`Carthage/Build`に入っている`.Project.version`というファイルが使われている。`.Project.version`はCarthageがチェックアウトしたソースのcommitish(SHA1ハッシュやタグなどのコミットを参照するもの)と、ビルドしたフレームワークのSHA256ハッシュを持っている。これらの値はつまるところ、`Carthage/Build`に入っているフレームワークのバージョンが`Cartfile.resolved`が指しているバージョンと一致しているかどうかの確認に使われる。この辺りのことは、[Documentation/VersionFile.md](https://github.com/Carthage/Carthage/blob/42b55b381ce77df1ac5939040ccb748f0dfdbf51/Documentation/VersionFile.md)に書かれている。

フレームワークがSwiftのものだった場合、CarthageはフレームワークがビルドされたSwiftのバージョンと、ローカルのSwiftのバージョンが一致しているかどうかもチェックしてくれる。これは[Source/CarthageKit/VersionFile.swift](https://github.com/Carthage/Carthage/blob/da14bf65a97d5af3e5eee418d64df8428b99b435/Source/CarthageKit/VersionFile.swift)辺りを読むとわかる。

要するに、Carthageはライブラリを更新した時には更新されたフレームワークだけをビルドくれるし、Swiftのバージョンが変えた時にはSwiftのバージョンが食い違ってくれるものだけどビルドしてくれるという、dependency managerとして至極真っ当なキャッシュの管理をしているということがわかる。これは後ほど説明するパーシャルキャッシュを使う上で重要となる。

## CircleCIのイミュータブルなキャッシュ

CircleCIではdependencyのキャッシュをキー毎に持つことができる。特徴的なのは、キーに対するキャッシュが完全にイミュータブルという点で、1度キーにキャッシュを保存したら同じキーには2度と書き込むことができない。なので、同じキーに対して常に同じキャッシュ(あるいは同じものとして扱えるキャッシュ)が生成されるように、キーを設計する必要がある。

Carthageを使う場合、`Carthage/Build`がキャッシュの対象となる。`Carthage/Build`にビルドされるフレームワークは、Swiftのバージョンとフレームワークのバージョンの2つによって変わるので、これらをキャッシュキーに含める必要がある。ここではSwiftのバージョンは手動で指定し、フレームワークのバージョンは`Cartfile.resolved`のチェックサムで表現し、`{% raw %}carthage-swift4.2-{{ checksum "Cartfile.resolved" }}{% endraw %}`をキーとした。

このキーを使って、読み込みと保存の設定を以下のようにする。

```yaml
{% raw %}steps:
  - restore_cache:
      keys:
        - carthage-swift4.2-{{ "checksum Cartfile.resolved" }}
  - run: carthage bootstrap --cache-builds --platform iOS
  - save_cache:
      key: carthage-swift4.2-{{ "checksum Cartfile.resolved" }}
      paths: Carthage/Build{% endraw %}
```

## CircleCIのパーシャルキャッシュ

CircleCIにはパーシャルキャッシュというものがある。これはキーに対するキャッシュが存在しない時に使われるキャッシュで、別のキーのキャッシュでも一部は再利用できるだろうという予測に基づいている。例えば、RxSwiftとNukeとLottieを使っていて、RxSwiftのみを更新した場合、`Cartfile.resolved`が変更されるのでキャッシュのキーは変わるが、従来のキーのキャッシュでもNukeとLottieはそのまま使えるという感じ。

パーシャルキャッシュを使うには、`steps.restore_cache.keys`にパーシャルキャッシュをロードするキーのプレフィクスを追加する。CircleCIは1つ目のキーから順番に前方一致でマッチングを行い、ヒットしたキャッシュのうち最新のものを使用する。

```yaml
{% raw %}
steps:
  - restore_cache:
      keys:
        - carthage-swift4.2-{{ "checksum Cartfile.resolved" }}
        - carthage-swift4.2-
        - carthage-
  - run: carthage bootstrap --cache-builds --platform iOS
  - save_cache:
      key: carthage-swift4.2-{{ "checksum Cartfile.resolved" }}
      paths: Carthage/Build{% endraw %}
```

上記の例では、2番目のキーがマッチするのは、ライブラリを更新して`Cartfile.resolved`も更新された時となる。この時、同じSwiftのバージョンで最近ビルドされた`Carthage/Build`がキャッシュとして使われ、Carthageは`Cartfile.resolved`と`Carthage/Build`で異なるバージョンになっているフレームワークのみをビルドする。例えば、RxSwiftとNukeとLottieを使っていて、RxSwiftを更新した場合、Carthageが再ビルドするのはRxSwiftだけとなる。

3番目のキーがマッチするのは、異なるSwiftのバージョンを使う時となる。この時、とにかく最近にビルドされた`Carthage/Build`がキャッシュとして使われる。CarthageはSwiftのバージョンが異なっているフレームワークも再ビルドする。例えば、RxSwiftとNukeとLottieを使っていて、ライブラリのバージョンは変えずにSwiftのバージョンだけを変えた場合、RxSwiftとNukeが再ビルドされる。LottieはObjective-Cのフレームワークなのでキャッシュが使われる。

2番目のキーがマッチする場合も、3番目もキーがマッチする場合も、1度キャッシュがビルドされてしまえば、以降はどこのブランチでも1番目のキーがマッチするようになるので、再ビルドは全ブランチを通じて1回のみで済む。

## まとめ

CarthageとCircleCIのキャッシュの機能をマジメに使っていれば、フレームワークやSwiftのバージョンを更新にあたってCIのビルド時間を気にする必要はほとんどなくなる。ABIが安定化されたり、Swift Package ManagerがiOSをサポートしたりすれば状況は変わるだろうけど、同じような概念は頭に入れておくと良さそう。
