---
layout: post
title: "APIKit 2 (1): レスポンスに応じた独自のエラーを投げる"
date: 2016-05-19 00:23 +0900
---

APIKit 2がリリースされました🎉

これから数日に分けて、このバージョンの特徴をいくつか紹介しようと思います。

### Web APIのエラーレスポンス

大抵のWeb APIでは、エラーレスポンスが定義されています。たとえば、GitHub APIではHTTPステータスコードに応じて次のようなレスポンスが返されます。

400 Bad Request

```json
{"message":"Problems parsing JSON"}
```

422 Unprocessable Entity

```json
{
  "message": "Validation Failed",
  "errors": [
    {
      "resource": "Issue",
      "field": "title",
      "code": "missing_field"
    }
  ]
}
```

今回は、このようなエラーをリクエストの呼び出し側に伝える方法を説明します。なお、この説明は[Defining Request Protocol for Web Service](https://github.com/ishkawa/APIKit/blob/2.0.0/Documentation/DefiningRequestProtocolForWebService.md)のエラーの扱いをもう少し詳しく説明したものとなります。

### サービス用のリクエストプロトコル

APIKitでは、特定のサービス(Web API)向けのリクエストの特徴をまとめるために、サービス用のリクエストプロトコルを定義します。今回はGitHub APIを例としているので、`baseURL`のデフォルト値が`https://api.github.com`となっている`GitHubRequestType`を定義しました。

```swift
protocol GitHubRequestType: RequestType {

}

extension GitHubRequestType {
    var baseURL: NSURL {
        return NSURL(string: "https://api.github.com")!
    }
}
```

本記事のタイトルの"レスポンスに応じた独自のエラーを投げる"という動作は、このリクエストプロトコル上に定義します。動作を定義する前に、まずは投げる対象のエラーの型を定義します。

### エラーレスポンスの構造体

GitHub APIのエラーレスポンスは次のような構造体で表せます。ここでは話を単純にするために、422の`errors`の配列のマッピングは省いています。

```swift
struct GitHubError: ErrorType {
    let message: String

    init(object: AnyObject) {
        message = object["message"] as? String ?? "Unknown Error"
    }
}
```

### レスポンスに応じたエラーを投げる

APIKit 2では、`interceptObject(_:URLResponse:)`でレスポンスの`AnyObject`を横取りすることができます。次の例では、HTTPステータスコードが`200..<300`なら通常通りにレスポンスの`AnyObject`を返し、`400`または`422`なら`AnyObject`から`GitHubError`を生成して`throw`し、それ以外の場合は適当なエラーを`throw`しています。

```swift
extension GitHubRequestType {
    func interceptObject(object: AnyObject, URLResponse: NSHTTPURLResponse) throws -> AnyObject {
        switch URLResponse.statusCode {
        case 200..<300:
            return object

        case 400, 422:
            throw GitHubError(object)

        default:
            throw RequestError.UnacceptableStatusCode(URLResponse.statusCode)
        }
    }
}
```

### エラーをハンドルする

APIKit 2のリクエスト実行のエラーは次のような列挙型となっています。

```swift
public enum SessionTaskError: ErrorType {
    case ConnectionError(ErrorType)
    case RequestError(ErrorType)
    case ResponseError(ErrorType)
}
```

`SessionTaskError`はエラーの発生箇所を表し、実際に何が起きたかはそれぞれの連想値が表します。`interceptObject(_:URLResponse:)`で投げたエラーはレスポンス由来のエラーなので、`ResponseError`の連想値に入ります。したがって、`Session`の`sendRequest(_:)`では、このエラーを次のように受け取れます。

```swift
let request = GitHubAPI.SearchRepositoriesRequest(query: "APIKit")

Session.sendRequest(request) { result in
    switch result {
    case .Success(let response):
        print("response: ", response)

    case .Failure(let error):
        switch error {
        case .ConnectionError(let error):
            print("Connection Error: \(error)")

        case .ResponseError(let error as GitHubError):
            // errorの型はGitHubErrorなのでmessageプロパティが使える
            print("GitHub API Error: \(error.message)")

        default:
            print("Unknown Error: \(error)")
        }
    }
}
```

こうして、独自に定義したエラーをリクエストの呼び出し側に伝えることができました。

実際には、毎回`UIViewController`などでこう書くのは面倒なので、以下のような`UIAlertController`のエクステンションを用意することになるかと思います。

```swift
extension UIAlertController {
    init(error: SessionTaskError) {
        

    }
}
```
