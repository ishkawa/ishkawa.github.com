---
layout: post
title: "APIKit 2 (1): レスポンスに応じた独自のエラーを投げる"
date: 2016-05-24 00:20 +0900
---

**2016/09/24**: APIKit 3向けに内容をアップデートしました。

--

### Web APIのエラーレスポンス

大抵のWeb APIでは、エラーレスポンスが定義されています。たとえば、GitHub APIではHTTPステータスコードに応じて次のようなレスポンスが返されます。

400 Bad Request

```json
{"message":"Problems parsing JSON"}
```

422 Unprocessable Entity

```json
{
  "message": "Validation Failed",
  "errors": [
    {
      "resource": "Issue",
      "field": "title",
      "code": "missing_field"
    }
  ]
}
```

今回は、このようなエラーをリクエストの呼び出し側に伝える方法を説明します。なお、この説明は[Defining Request Protocol for Web Service](https://github.com/ishkawa/APIKit/blob/2.0.0/Documentation/DefiningRequestProtocolForWebService.md)のエラーの扱いをもう少し詳しく説明したものとなります。

### サービス用のリクエストプロトコル

APIKitでは、特定のサービス(Web API)向けのリクエストの特徴をまとめるために、サービス用のリクエストプロトコルを定義します。今回はGitHub APIを例としているので、`baseURL`のデフォルト値が`https://api.github.com`となっている`GitHubRequest`を定義しました。

```swift
protocol GitHubRequest: Request {

}

extension GitHubRequest {
    var baseURL: URL {
        return URL(string: "https://api.github.com")!
    }
}
```

本記事のタイトルの"レスポンスに応じた独自のエラーを投げる"という動作は、このリクエストプロトコル上に定義します。動作を定義する前に、まずは投げる対象のエラーの型を定義します。

### エラーレスポンスの構造体

GitHub APIのエラーレスポンスは次のような構造体で表します。

```swift
// 話を単純にするために422の`errors`は省略。
struct GitHubError: Error {
    let message: String

    init(object: Any) {
        let dictionary = object as? [String: Any]
        message = dictionary?["message"] as? String ?? "Unknown error occurred"
    }
}
```

### レスポンスに応じた独自のエラーの生成

APIKitでは、`intercept(object:urlResponse:)`でレスポンスの`Any`を横取りすることができます。次の例では、HTTPステータスコードが`200..<300`なら通常通りにレスポンスの`Any`を返し、それ意外なら`Any`から`GitHubError`を生成して`throw`しています。

```swift
extension GitHubRequest {
    func intercept(object: Any, urlResponse: HTTPURLResponse) throws -> Any {
        guard (200..<300).contains(urlResponse.statusCode) else {
            throw GitHubError(object: object)
        }

        return object
    }
}
```

### リクエストの結果の受け取り

APIKitではリクエストの送信は、`Session`の`send(_:handler:)`で行い、その結果は`Result<Request.Response, SessionTaskError>`として受け取ります。エラーの型である`SessionTaskError`は、次のように定義された列挙型です。

```swift
public enum SessionTaskError: Error {
    case connectionError(Error)
    case requestError(Error)
    case responseError(Error)
}
```

`SessionTaskError`はエラーの発生箇所を表し、実際に何が起きたかはそれぞれの連想値が表します。`intercept(object:urlResponse:)`で投げたエラーはレスポンス由来のエラーなので、`responseError`の連想値に入ります。

### 独自のエラーのマッチング

いざリクエストを実行してみると、通信に失敗したり、JSONが壊れていたり、サーバーが変なレスポンスを返したりと結果はさまざまです。その中から、想定内のエラーレスポンス`GitHubError`をマッチングするには、以下のように`switch`文を書きます。

```swift
let request = GitHubAPI.SearchRepositoriesRequest(query: "APIKit")

Session.send(request) { result in
    switch result {
    case .success(let response):
        print("Response: ", response)

    case .failure(.responseError(let gitHubError as GitHubError)):
        print("GitHub error: \(gitHubError.message)")

    case .failure(let error):
        print("Unknown error: \(error)")
    }
}
```

コード中の`gitHubError`という定数の型は`GitHubError`になっているので、`GitHubError`のプロパティである`message`にもアクセスできるというわけです。

こうして、独自に定義したエラーをリクエストの呼び出し側に伝えることができました。

### まとめ

`Any`へのサブスクリプトや`HTTPURLResponse`のステータスコードの比較など、より原始的(?)な型を扱うコードはミスを犯しやすいです。今回の例では、こういった類のコードをプロトコル側にまとめることができました。結果として、`send(_:handler)`を実行する`UIViewController`などは安全な操作だけで済むようになり、アプリの品質も上がるかもしれません。
